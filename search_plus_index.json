{"./":{"url":"./","title":"前言","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Introduction Introduction 一些学习资料 https://c4xx.gitbook.io/c4 kill -9 $(lsof -t -i:35729) Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 19:30:26 "},"MemoryManager/":{"url":"MemoryManager/","title":"内存管理","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 内存管理 内存管理原则 访问 __weak 修饰的变量，是否已经被注册在了 @autoreleasePool 中？为什么？ ARC 内存管理规则 悬垂指针和野指针区别 BAD_ACCESS 声明情况下回出现？如何调试和？ 被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？（内存管理方便，考底层weak实现） 关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将所有的关联对象的指针置空么？（底层runtime方面，考底层associated） 内存管理 iOS 使用引用计数来进行内存管理。当调用 reatin 的时候引用计数+1，当调用release 的时候引用计数-1，当引用计数为0的时候，对象销毁。 ARC，自动引用计数是编译器特性，会在编译时在适当的位置添加retain、release操作。 内存管理原则 总则：谁持有谁释放。 所有权修饰符包括如下： __strong：强引用，持有对象。__ __weak：弱引用，不持有对象，对象销毁，指向该对象的属性置为nil。_ __unsafe_unretain：不安全修饰符，不持有对象，对象销毁，指向对象的属性不会置为nil，容易出现悬垂指针，发生奔溃，但是效率比weak高。 _autorelease 添加到autoreleasepool 的对象都会进行延迟释放。 不是以alloc、new、copy、mutableCopy创建的对象，会自动将返回值的对象注册到 autoreleasepool。 访问 __weak 修饰的变量，是否已经被注册在了 @autoreleasePool 中？为什么？ 访问weak修饰符的变量必须访问注册到autorelease中，因为weak持有对象的弱引用，而在访问对象的过程中，该对象可能被废弃，如果注册到autorelease中，那么在autorelease释放之前都能保证对象的存在。 id指针或对象的指针在没有显示指定时会被附加上_autorelease修饰符。 ARC 内存管理规则 不能使用retain、release、retainCount 不能使用NSDeallocateObject 不用显式调用dealloc 使用@autorelease代替NSAutoreleasepool 不能使用zone 显示转换 id 和 void* 悬垂指针和野指针区别 悬垂指针指的是，指向的内存已经释放了，但是指针还在。 野指针：未初始化的指针称为野指针。 BAD_ACCESS 声明情况下回出现？如何调试和？ 访问了已经被销毁的内存空间，就会报出这个错误。 根本原因是有 悬垂指针 没有被释放。 1、比较老的方法是打开Xcode 的 enabled zoombie。 2、设置全局断点看能否快速定位问题。 3、Address sanitizer。 4、或者使用 Instruments Zombies. https://devma.cn/blog/2016/11/10/ios-beng-kui-crash-jie-xi/ 被weak修饰的对象在被释放的时候会发生什么？是如何实现的？知道sideTable么？里面的结构可以画出来么？（内存管理方便，考底层weak实现） 对象在释放的时候会调用 dealloc 方法，内部会调用 objc_dispose，最后调用 objc_destoryInstance，然后再 objc_destoryInstance 内部会调用 weak_entry_remove 函数，通过在weak表中找到对象指针找到对应的entry，然后遍历entry中所有指向对象指针的weak变量指针，同时置为nil，最后把entry从weak表中移除。 关联对象有什么应用，系统如何管理关联对象？其被释放的时候需要手动将所有的关联对象的指针置空么？（底层runtime方面，考底层associated） 1、为分类手动实现成员变量的setter和getter方法，用于关联对象。 2、底层使用 AssociatedManager 管理关联对象，内部其实有一个哈希表来 AssociationMap 存储所有关联对象的。相当于把所有关联对象存在一个哈希map中，map的key是这个对象的指针地址，而map的value是另一个哈希map（objectAssociationmap），里面保存关联对象的KV对。objectAssociationmap 内部是 value 和 policy，根据指定的 policy 进行内存管理。 3、释放的时候不需要手动设置指针为nil，因为 runtime 在对象销毁函数destructInstance中会判断这个对象有没有关联对象，如果有会自动做关联对象的清除。 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:25:00 "},"MemoryManager/weak.html":{"url":"MemoryManager/weak.html","title":"weak 实现原理","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 weak 实现原理 修饰符定义 SideTable weaktablet weakentryt weakregisterno_lock weakclearno_lock 小结 参考 weak 实现原理 修饰符定义 当__weak修饰的变量，在所引用的对象被废弃时，则变量自动设置为nil。 使用__weak修饰的变量，即是注册到 autoReleasePool 中的对象。 SideTable 首先我们来了解一下SideTable struct SideTable { spinlock_t slock; RefcountMap refcnts; weak_table_t weak_table; SideTable() { memset(&weak_table, 0, sizeof(weak_table)); } ~SideTable() { _objc_fatal(\"Do not delete SideTable.\"); } void lock() { slock.lock(); } void unlock() { slock.unlock(); } void forceReset() { slock.forceReset(); } // Address-ordered lock discipline for a pair of side tables. template static void lockTwo(SideTable *lock1, SideTable *lock2); template static void unlockTwo(SideTable *lock1, SideTable *lock2); }; sideTable 是一个结构体，内部有一个互斥锁，这把锁的作用是在多线程环境下防止资源访问产生的竞态条件。 refcountMap 是用于管理对象的引用计数。 weak_table_t 是用来管理弱引用依赖表。 weak_table_t struct weak_table_t { weak_entry_t *weak_entries; size_t num_entries; uintptr_t mask; uintptr_t max_hash_displacement; }; 它是全局的弱引用表，存储对象的 ids 作为 key，weak_entry_t 结构体对象作为值。 weak_entries 保存了所有指向指定对象的 weak 指针。 num_entries 是存储空间，表明存储 weak_entry_t 的数量。 // 添加一个 到弱引用表中。 id weak_register_no_lock(weak_table_t *weak_table, id referent, id *referrer, bool crashIfDeallocating); // 从弱引用表中移除一个 void weak_unregister_no_lock(weak_table_t *weak_table, id referent, id *referrer); // 将所有的弱引用指针置为nil void weak_clear_no_lock(weak_table_t *weak_table, id referent); weak_entry_t struct weak_entry_t { DisguisedPtr referent; union { struct { weak_referrer_t *referrers; uintptr_t out_of_line_ness : 2; uintptr_t num_refs : PTR_MINUS_2; uintptr_t mask; uintptr_t max_hash_displacement; }; struct { // out_of_line_ness field is low bits of inline_referrers[1] weak_referrer_t inline_referrers[WEAK_INLINE_COUNT]; }; }; bool out_of_line() { return (out_of_line_ness == REFERRERS_OUT_OF_LINE); } weak_entry_t& operator=(const weak_entry_t& other) { memcpy(this, &other, sizeof(other)); return *this; } weak_entry_t(objc_object *newReferent, objc_object **newReferrer) : referent(newReferent) { inline_referrers[0] = newReferrer; for (int i = 1; i weak_register_no_lock weak 修饰符的属性整个注册调用栈如下： - _object_setIvar - objc_storeWeak - storeWeak - weak_register_no_lock 整个添加流程如下： storeWeak 内部先初始化两个 sideTable，初始化 sideTable 的同时，会创建弱引用表。然后判断是否存在旧值，存在就先清除，调用 weak_unregister_no_lock；然后添加新值，调用 weak_register_no_lock。 接下来是添加步骤 如果以对象的指针能找到对应的 entry，就在 entry 中添加引用对象；反之进行下述操作。 以指向对象的指针作为 key，weak修饰符变量作为 value，创建新的 entry；超过75%之后，开始以原来的2倍进行扩容；最后添加到 weak table 中。 weak_clear_no_lock 对象被废弃的整个调用栈如下： - dealloc - _objc_rootDealloc - rootDealloc - object_dispose - objc_destructInstance - clearDeallocating - sidetable_clearDeallocating - weak_clear_no_lock objc_destructInstance 内部实现： // Read all of the flags at once for performance. bool cxx = obj->hasCxxDtor(); bool assoc = obj->hasAssociatedObjects(); // This order is important. if (cxx) object_cxxDestruct(obj); if (assoc) _object_remove_assocations(obj); obj->clearDeallocating(); 调用C++的析构器。 判断有没有关联对象，移除关联对象引用。 调用 clearDeallocating SideTable& table = SideTables()[this]; // clear any weak table items // clear extra retain count and deallocating bit // (fixme warn or abort if extra retain count == 0 ?) table.lock(); // 遍历引用计数表 RefcountMap::iterator it = table.refcnts.find(this); if (it != table.refcnts.end()) { // 找有有弱引用标志的 weak table if (it->second & SIDE_TABLE_WEAKLY_REFERENCED) { // 清除弱引用 weak_clear_no_lock(&table.weak_table, (id)this); } // 移除整个计数表 table.refcnts.erase(it); } table.unlock(); 然后通过 weak_clear_no_lock 的源码来分析下具体的释放流程是怎样的？ void weak_clear_no_lock(weak_table_t *weak_table, id referent_id) { objc_object *referent = (objc_object *)referent_id; weak_entry_t *entry = weak_entry_for_referent(weak_table, referent); if (entry == nil) { return; } // zero out references weak_referrer_t *referrers; size_t count; if (entry->out_of_line()) { referrers = entry->referrers; count = TABLE_SIZE(entry); } else { referrers = entry->inline_referrers; count = WEAK_INLINE_COUNT; } for (size_t i = 0; i 先通过赋值对象的指针在 table 中，找到所有存储weak修饰符变量指针的 entry。 然后判断该 entry 有没有扩容，去动态数组中查找referrers，否则从静态数组中查找referrers。 通过遍历找到所有的弱引用 referrer，同时置为nil。 把存储的 entry 从 table 中删除。 最后从引用计数表中删除废弃对象为 key 的所有记录。 小结 首先在 runtime 中维护了一个 weak 表，其实是一个 hash 表。用于存储指向某个对象的所有weak指针，key是指对象的地址，value是weak指针的地址（这个地址的值是所指对象的地址）数组。 整个过程分为三步： objc_initWeak，初始化创建 SideTable，然后通过 SideTable 创建对应的 weak table。 objc_storeWeak， 添加引用时，旧对象解除注册操作，新对象添加注册操作。把引用对象的地址作为 key，weak 修饰符的变量地址作为 value 存储到 weak table 中。 dealloc，对象释放时，先通过对象指针找到存储 weak 修饰符变量指针的 entry；然后找出所有的 referrers；再通过遍历 referrers 获取到每一个 referrer，同时置为 nil；接着把存储的 entry 从 table 中移除；最后从引用技术表中删除废弃对象为 key 的所有记录。 参考 http://www.cocoachina.com/articles/18962 https://juejin.im/post/5defc49951882512290f1e87?utm_source=gold_browser_extension Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 20:29:53 "},"MemoryManager/autoreleasepool.html":{"url":"MemoryManager/autoreleasepool.html","title":"Autoreleasepool 实现原理","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Autoreleasepool 实现原理 autoreleasepool AutoReleasePoolPage POOL_SENTINEL Push autorelease操作 pop 什么时候调用autoreleasepool autorelease对象在何时释放 参考 Autoreleasepool 实现原理 autoreleasepool 它是什么？直接使用 clang 让编译器重写这个文件 { __AtAutoreleasePool __autoreleasepool; } struct __AtAutoreleasePool { __AtAutoreleasePool() {atautoreleasepoolobj = objc_autoreleasePoolPush();} ~__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj);} void * atautoreleasepoolobj; }; 结构体 __AtAutoreleasePool 在初始化的时候调用 objc_autoreleasePoolPush()，在析构的时候调用 objc_autoreleasePoolPop。 上述两个函数的实现通过底层代码查看，该实现在 NSObject.mm 文件中： void * objc_autoreleasePoolPush(void) { // 调用了AutoreleasePoolPage中的push方法 return AutoreleasePoolPage::push(); } void objc_autoreleasePoolPop(void *ctxt) { // 调用了AutoreleasePoolPage中的pop方法 AutoreleasePoolPage::pop(ctxt); } AutoReleasePoolPage 线程的自动释放池是一个指针堆栈，每个指针要么是要释放的对象，要么是自动释放池边界。当自动释放进行pop时，边界对象之前的对象都要被释放。这个堆栈被分配成一个双链表页面， magic_t const magic; // 一个AutoreleasePoolPage中会存储多个对象 // next指向的是下一个AutoreleasePoolPage中下一个为空的内存地址（新来的对象会存储到next处） id *next; // 保存了当前页所在的线程(一个AutoreleasePoolPage属于一个线程，一个线程中可以有多个AutoreleasePoolPage) pthread_t const thread; // AutoreleasePoolPage是以双向链表的形式连接 // 前一个节点 AutoreleasePoolPage * const parent; // 后一个节点 AutoreleasePoolPage *child; uint32_t const depth; uint32_t hiwat; magic，用于对当前 AutoreleasePoolPage 完整性的校验 next，指向的是下一个AutoreleasePoolPage中下一个为空的内存地址 tread，当前线程 parent，前一个节点 child，后一个节点 POOL_SENTINEL 哨兵对象只是 nil 的别名。在每个自动释放池初始化调用 objc_autoreleasePoolPush 的时候，都会把一个 POOL_SENTINEL push 到自动释放池栈顶。并且返回这个对象。 通过 AutoReleasePoolpage::pop 操作来负责对pool中的 autoreleased 对象执行 release 操作，直到第一个哨兵对象。 Push void * objc_autoreleasePoolPush(void) { // 调用了AutoreleasePoolPage中的push方法 return AutoreleasePoolPage::push(); } objc_autoreleasePoolPush 内部是调用 page 的 push 方法。 static inline void *push() { id *dest; // POOL_BOUNDARY就是nil // 首先将一个哨兵对象插入到栈顶 if (DebugPoolAllocation) { // Each autorelease pool starts on a new pool page. dest = autoreleaseNewPage(POOL_BOUNDARY); } else { dest = autoreleaseFast(POOL_BOUNDARY); } assert(dest == EMPTY_POOL_PLACEHOLDER || *dest == POOL_BOUNDARY); return dest; } push 方法就是先创建一个新的 autoreleasepool，然后往 next 位置插入一个哨兵对象，并且返回插入的内存地址。 static inline id *autoreleaseFast(id obj) { // hotPage就是当前正在使用的AutoreleasePoolPage AutoreleasePoolPage *page = hotPage(); if (page && !page->full()) { // 有hotPage且hotPage不满，将对象添加到hotPage中 return page->add(obj); } else if (page) { // 有hotPage但是hotPage已满 // 使用autoreleaseFullPage初始化一个新页，并将对象添加到新的AutoreleasePoolPage中 return autoreleaseFullPage(obj, page); } else { // 无hotPage // 使用autoreleaseNoPage创建一个hotPage,并将对象添加到新创建的page中 return autoreleaseNoPage(obj); } } autoreleaseFast 函数在执行一个具体的插入操作时，分别对三种情况进行不同的处理。 当前page存在且没有满的时候，直接将对象添加到当前page中，即next指向的位置。 当前page存在且满的时候，创建一个新的page，并且将对象添加到新的page中。 当个page不存在的时候，创建一个新的page，并将对象添加到新创建的page中。 autorelease操作 autorelease操作其实就是调用AutoReleasePoolPage中的autorelease函数。 autorelease函数中其实也调用了autoreleasefast函数，跟push操作很类似。 autorelease操作插入的是一个具体的autoreleased对象。 pop void objc_autoreleasePoolPop(void *ctxt) { // 调用了AutoreleasePoolPage中的pop方法 AutoreleasePoolPage::pop(ctxt); } objc_autoreleasePoolPop 调用的就是 page 的 pop 方法。 static inline void pop(void *token) { AutoreleasePoolPage *page = pageForPointer(token); id *stop = (id *)token; page->releaseUntil(stop); if (page->child) { if (page->lessThanHalfFull()) { page->child->kill(); } else if (page->child->child) { page->child->child->kill(); } } } pop 中的 token 就是 push 函数的返回值。通过 pageForPointer 找到所在的 page，然后内存地址在 token 之后的所有对象都会被 release，直到 page 的 next 指针指向边界对象。 调用 releaseUntil 方法释放栈中的对象，直到 stop。 调用 chil 的 kill 方法。 // 释放AutoreleasePoolPage中的对象，直到next指向stop while (this->next != stop) { // Restart from hotPage() every time, in case -release // autoreleased more objects // hotPage可以理解为当前正在使用的page AutoreleasePoolPage *page = hotPage(); // fixme I think this `while` can be `if`, but I can't prove it // 如果page为空的话，将page指向上一个page // 注释写到猜测这里可以使用if，我感觉也可以使用if // 因为根据AutoreleasePoolPage的结构，理论上不可能存在连续两个page都为空 while (page->empty()) { page = page->parent; setHotPage(page); } page->unprotect(); // obj = page->next; page->next--; id obj = *--page->next; memset((void*)page->next, SCRIBBLE, sizeof(*page->next)); page->protect(); // POOL_BOUNDARY为nil，是哨兵对象 if (obj != POOL_BOUNDARY) { // 释放obj对象 objc_release(obj); } } // 删除双向链表中的每一个page void kill() { // Not recursive: we don't want to blow out the stack // if a thread accumulates a stupendous amount of garbage AutoreleasePoolPage *page = this; // 找到链表最末尾的page while (page->child) page = page->child; AutoreleasePoolPage *deathptr; // 循环删除每一个page do { deathptr = page; page = page->parent; if (page) { page->unprotect(); page->child = nil; page->protect(); } delete deathptr; } while (deathptr != this); } 什么时候调用autoreleasepool 编译器检查是否以alloc、new、copy、mutableCopy开始，如果不是则自动将返回值对象注册到autoreleasepool 以 __weak 修饰的对象，会注册到autoreleasepool 调用Foundation 对象的类方法会注册到autoreleasepool中。 id的指针或对象的指针，在没有显示的指定修饰符，会被默认附加上__autoreleaseing 修饰符。 autorelease对象在何时释放 在没有手动加入 autoreleasepool 的情况下，autorelease 对像是在当前runloop迭代结束后释放的，而它能够释放的原因是系统在每个runloop迭代中加入自动释放池的push和pop操作。 参考 https://cloud.tencent.com/developer/article/1350726 https://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/ Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:25:20 "},"MemoryManager/memoryleak.html":{"url":"MemoryManager/memoryleak.html","title":"内存泄漏","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 内存泄漏 内存泄漏形式 OC 中出现泄漏的点 如何检测泄漏？ 参考 内存泄漏 内存泄漏形式 Leaked memory：未引用的内存不能使用或释放。 Abandoned memory：废弃掉的内存，但是App任然引用。 Cached memory：App任然使用的内存，可以再次获取已获得更好的性能。 OC 中出现泄漏的点 NSTimer ViewController，delegate Block 对象之间的互相引用 NSURLSession，delegate 是 strong 类型。 如果使用到 CF 内部 create 和 copy 的方法时，注意需要及时释放 如何检测泄漏？ 静态检测，Analyze。 Instrument，Leaks，Allocations 第三方工具 MLeaksFinder 参考 https://www.jianshu.com/p/e9d989c12ff8 https://wereadteam.github.io/2016/02/22/MLeaksFinder/ Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 20:30:53 "},"Basic/":{"url":"Basic/","title":"Foudation","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 为什么一定要在主线程里面更新UI？ 哈希表 Hash Table NSDictionary的实现原理是什么？ 什么是指针常量和常量指针？ 不借用第三个变量，如何交换两个变量的值？要求手动写出交换过程。 iOS 事件传递和响应 NSCache 和 NSDictionary 的区别 synthesize 和 dynamic 分别有什么作用 默认关键字 使用copy关键字声明属性，为什么？ 深拷贝、浅拷贝 @synthesize合成规则是如何的？ 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？ 在 protocol 和 category 中如何使用property 常见的Exception Autolayout 为什么一定要在主线程里面更新UI？ 哈希表 Hash Table https://juejin.im/post/5b56155e6fb9a04f8b78619b#heading-1 NSDictionary底层实现其实是一个哈希表。哈希表的本质是一个数组，数组的每一个元素是一个箱子，箱子中存放的是键值对。 使用数组存储元素，一个索引对应一个数据，元素很多也叫桶 buckets。 哈希表存储过程： 1、传入 key， 根据哈希函数算出它的哈希值 index。index 必须是整数。 2、假设箱子的个数为 n，那么这个键值对应该放在第 index % n 的箱子中。 3、哈希函数计算出的 index 相同就会产生哈希冲突，就是用开放寻址法或拉链发解决冲突。 4、开放寻址：按照一定规则向其他地址探测，直到遇到空桶。 5、再哈希法、拉链法通过链表将所有相同 index 元素串起来。有可能链表转成红黑树。 6、如果使用双向链表容易浪费内存，多了一个指针。 使用拉链法解决哈希冲突时，每个箱子其实是一个链表，属于同一个箱子的键值对都会排在链表中。 还有一个负载因子，表示哈希表的空满程度。 NSDictionary的实现原理是什么？ HashTable 哈希表实现的。 什么是指针常量和常量指针？ 指针常量本质是一个常量，表示是一个指针常量，指针说明常量类型。 常量指针本质是一个指针，表示指针指向的内容是一个常量。指向的内容不允许修改。 不借用第三个变量，如何交换两个变量的值？要求手动写出交换过程。 void swap(int &a, int& b) { a = a ^ b; b = a ^ b; a = a ^ b; } iOS 事件传递和响应 http://smnh.me/hit-testing-in-ios/ https://stackoverflow.com/questions/4961386/event-handling-for-ios-how-hittestwithevent-and-pointinsidewithevent-are-r/4961484#4961484 iOS 事件流有两条线，事件传递（分发）和事件响应 一、事件传递 当用户触摸了设备的屏幕，此时系统会产生一个 UIEvent 被添加到 UIApplication 管理的事件队列，等到下一个 runloop 到来之时添加到 runloop 中。然后从 UIApplication 的事件队列取出事件交由 UIWindow 主窗口开始处理，接下来就是 hitTest 的主要流程。 hitTest： UIWindow 调用 pointInSide:withEvent: 来判断触摸点是否在当前视图上。 如果返回NO，则 hitTest 返回nil。如果返回YES，则向当前视图的子视图发送 hitTest 事件。 子视图从上至下遍历视图，依次判断触摸点是否在当前视图，如果是继续遍历。 如果最底层的子视图有返回非空对象，则hitTest就返回该对象。 如果返回的都是nil，则 hitTest 返回自身。 hitTest 找能响应事件的视图时，有三个限制条件防止hitTest继续往下找。 hidden=YES userInteractionEnabled=NO alpha 二、事件响应 事件产生之后由点击的视图首先判断能否处理，如果处理不了就会往视图的父视图进行传递，如果父视图还不能响应继续传递给根视图，如果还不响应传递给控制器，然后传递给主窗口，最后传递给UIApplication，如果还不能处理就直接废弃。 First Responser --> The Window --> The Application --> nil（丢弃） NSCache 和 NSDictionary 的区别 NSCache 会在内存紧张的时候自动清除缓存。 NSCache 是线程安全类，可以在多线程情况下不需要使用锁就可以添加和删除操作。 NSDictionary 的 key 是遵循 NSCopying 协议的。 synthesize 和 dynamic 分别有什么作用 property 有两个对应的词，一个是 synthesize，一个是 dynamic。 synthesize 是自动合成，编译器会自动为我们合成属性、存取方法。 dynamic 是告诉编译器，属性方法由自己实现，不需要自动合成。 dynamic 在使用的时候，需要注意的是没有实现属性方法，程序去调用的时候会crash。 默认关键字 常量类型： atomic、readwrite、assign 对象类型：atomic、readwrite、strong 使用copy关键字声明属性，为什么？ 保护类的封装性，类的属性不受外部干扰，copy 之后生成的是一个不可变副本，也就是个不可变对象。 如果使用 strong，类的封装性被破坏，在不确定因素下存在被外部修改的可能。 深拷贝、浅拷贝 1、深拷贝是内容拷贝 2、浅拷贝是指针拷贝 1、对于非集合类，对不可变对象copy是浅拷贝，其余都会深拷贝 2、对于集合类，不可变对象copy是浅拷贝，其余都是单层深拷贝 @synthesize合成规则是如何的？ 实例变量=成员变量=ivar 使用属性的话，编译器是自动编写setter和getter方法，此过程叫自动合成，编译器还会自动向类中添加适当类型的实例变量。 四条规则如下： 如果指定了成员变量的名称，会生成一个指定名称的成员变量。 如果这个成员变量已经存在，就不再生成。 如果是 @synthesize foo; 还会生成一个名称为foo的成员变量。 如果是 @synthesize foo = _foo; 就不会生成成员变量了. 在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？ 什么情况下不会自动合成。 同时重写了setter和getter 重写了只读属性的getter 使用了@dynamic 在@protocol中使用的属性 在category中定义的所有属性 重载的属性 如果子类重载了父类的属性，必须使用@synthesize进行手动合成ivar。 在 protocol 和 category 中如何使用property 只会生成 setter 和 getter 方法声明。 1、protocol 声明的属性，遵循该协议的类属性重写或者通过 @syncthesize 来自动合成。 2、category 声明的属性，需要使用associate object来关联对象。 常见的Exception SIGSEGV 重复释放对象 SIGABRT 收到abort信号，插入nil到数组中会遇到此类错误 SEGV 代表无效指针，比如空指针 SIGBUS 总线错误，地址对齐问题 SIGILL 尝试非法指令 Autolayout Auto Layout 拥有一套 Layout Engine 引擎，由它来主导页面的布局。App启动后，主线程的Run Loop会一直处于监听状态，当约束发生变化后会触发Deffered Layout Pass（延迟布局传递），在里面做容错处理（约束丢失等情况）并把view标识为dirty状态，然后Run Loop再次进入监听阶段。当下一次刷新屏幕动作来临（或者是调用layoutIfNeeded）时，Layout Engine 会从上到下调用 layoutSubviews() ，通过 Cassowary算法计算各个子视图的位置，算出来后将子视图的frame从Layout Engine拷贝出来，接下来的过程就跟手写frame是一样的了。 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:15:04 "},"Runtime/":{"url":"Runtime/","title":"Runtime","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Runtime 参考 向一个nil对象发送消息会发生什么？ self 和 super 的区别 objc_msgSend 和 [objc foo] 关系？ 说一下OC的反射机制？ Obj-C 对象、类的本质是通过什么数据结构实现的？ 一个 NSObject 对象占用多少内存空间？ classrot 和 classrwt 的区别？ 能否向编译后的类中添加实例变量？能否向运行时创建的类中添加实例变量？为什么？ category 如何加载？ category为什么不能添加实例变量？ category 编译过后，在什么时机跟原有类结合在一起 method swizzling 是否使用过，说一下在实际开发中的什么场景下使用过。 什么时候会报 unrecognized selector 的异常？ 消息查找流程 消息转发流程 objcmsgForward 是做什么的？直接调用会发生什么？ 一个objc对象如何进行内存布局？测试对象图的结构 讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的？为什么对象方法没有保存的对象结构体里，而是保存在类对象的结构体里？ iOS 中内省的几个方法？class方法和objc_getClass方法有什么区别? 在运行时创建类的方法objc_allocateClassPair的方法名尾部为什么是pair（成对的意思）？ load和initialize方法分别在什么时候调用的？ Runtime 参考 https://halfrost.com/objc_runtime_isa_class/ https://halfrost.com/objc_runtime_objc_msgsend/ https://halfrost.com/how_to_use_runtime/ 向一个nil对象发送消息会发生什么？ 运动时不会有任何影响，是有效的。 如果一个方法返回值是一个对象，发送给nil的消息将返回0。如果向一个nil对象发送消息，首先寻找对象的isa指针就是0地址返回了。所以不会出现任何错误。 self 和 super 的区别 self 是类的隐藏参数，指向当前调用方法的类的实例。 super 是编译器标识符，和self指向的同一个消息接受者。 super 会告诉编译器去父类找相应的方法，而不是在本类中。 objc_msgSend 和 [objc foo] 关系？ 编译之后就变成 objc_msgSend，第一参数是消息的接受者，第二个参数消息的选择子。 说一下OC的反射机制？ OC 是一门动态语言，可以在运行时阶段为已有类添加方法列表、可以动态创建类并且添加成员变量等等。还可以在程序执行阶段，通过多种反射方法，以字符串的形式获取对应的类和选择子，还可以判读当前类是否是某个类的子类或类等等。 常用的例子：通过 runtime 给模型自动设置属性值。通过 runtime 给对象自动实现归档、拷贝功能。 Obj-C 对象、类的本质是通过什么数据结构实现的？ 都是结构体。 实例对象 objc_object 内部只有一个 isa 指针 类对象 objc_class 内部有isa、cache、superClass、bits等，元类跟类对象差不多。 objc_object 内部是一个 isa_t 类型指针。 struct objc_object { private: isa_t isa; } objc_object 继承自 objc_class struct objc_class : objc_object { // Class ISA; Class superclass; cache_t cache; // formerly cache pointer and vtable class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags class_rw_t *data() { return bits.data(); } 一个 NSObject 对象占用多少内存空间？ 16字节。一个 isa 占8位，不满16补足16位。 class_ro_t 和 class_rw_t 的区别？ ObjC 类中的属性、方法还有遵循的协议等信息都保存在 class_rw_t 中 rw 中有一个指向常量的指针 ro。 ro 存储了当前类在编译期就已经确定的属性、方法以及遵循的协议。 通过底层 realizeClass 方法将 class_ro_t 常量赋值给 class_rw_t 中的 ro 常量。然后通过 methodizeClass 将 ro 的方法列表、属性列表、协议列表添加到 class_rw_t 中对应的字段中，并且最后还将分类中的方法、属性、协议添加到对应的字段中。 struct class_ro_t { uint32_t flags; uint32_t instanceStart; uint32_t instanceSize; #ifdef __LP64__ uint32_t reserved; #endif const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; // 方法列表 protocol_list_t * baseProtocols; // 协议列表 const ivar_list_t * ivars; // 成员变量列表 const uint8_t * weakIvarLayout; property_list_t *baseProperties; // 属性列表 struct class_rw_t { // Be warned that Symbolication knows the layout of this structure. uint32_t flags; uint32_t version; const class_ro_t *ro; // 指向常量 ro method_array_t methods; // 方法数组 property_array_t properties; // 属性数组 protocol_array_t protocols; // 协议数组 Class firstSubclass; Class nextSiblingClass; } 能否向编译后的类中添加实例变量？能否向运行时创建的类中添加实例变量？为什么？ class_ro_t 中有如下定义： const uint8_t * ivarLayout; const char * name; method_list_t * baseMethodList; protocol_list_t * baseProtocols; const ivar_list_t * ivars; ivars 声明的是常量，也就是说在编译期的时候，类的 ivars 和 ivarLayout 就已经确定完成，不可再添加实例变量。 运行时可以通过 class_allocationClassPair 和 class_registerClassPair 创建类，并且通过 class_addIvar 添加实例变量。 category 如何加载？ struct category_t { const char *name; classref_t cls; struct method_list_t *instanceMethods; // 实例方法 struct method_list_t *classMethods; // 类方法 struct protocol_list_t *protocols; // 协议列表 struct property_list_t *instanceProperties; // 属性列表 // Fields below this point are not always present on disk. struct property_list_t *_classProperties; method_list_t *methodsForMeta(bool isMeta) { if (isMeta) return classMethods; else return instanceMethods; } property_list_t *propertiesForMeta(bool isMeta, struct header_info *hi); }; category 是在运行时，通过 realizedClass 和 methodizeClass 将 category 中的方法、属性、协议和所属类合并的。 category 是在编译之后，runtime 进行objc setup的阶段，调用_objc_init，然后通过 read_images 读取所有类的相关信息，然后调用 realizeClass 和 methodizeClass 进行和原有类的方法列表、协议列表进行合并，最后添加到 class_rw_t 结构体中。 category为什么不能添加实例变量？ 因为在编译阶段就已经确定了类的内存布局结构，并且category中并没有ivar_list的声明。 category 编译过后，在什么时机跟原有类结合在一起 程序启动后，通过编译之后，Runtime 会进行初始化，调用 _objc_init。 然后会 map_images。 接下来调用 map_images_nolock。 再然后就是 read_images，这个方法会读取所有的类的相关信息。 最后是调用 reMethodizeClass:，这个方法是重新方法化的意思。 在 reMethodizeClass: 方法内部会调用 attachCategories: ，这个方法会传入 Class 和 Category ，会将方法列表，协议列表等与原有的类合并。最后加入到 class_rw_t 结构体中。 method swizzling 是否使用过，说一下在实际开发中的什么场景下使用过。 1、UIViewController 生命周期的 PV 打点。 2、点击事件的打点等等。 3、防 crash。 什么时候会报 unrecognized selector 的异常？ OC的方法调用的本质是消息的传递。 当调用一个对象上的某个方法，而该对象没有实现这个方法的时候，可以进行”消息转发“机制。 OC是动态语言，每个方法的调用在运行会被动态转为消息发送，即objc_msgsend 消息查找流程 消息的传递是通过 objc_msgSend 进行发送。 查找的顺序，通过 isa 找到类，通过类的 superClass 找父类。 先找缓存，后遍历方法列表。 找到即返回，并且添加缓存。 如果没找到走消息转发。 消息转发流程 objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常 unrecognized selector sent to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会： 动态方法解析，resolveInstanceMethod 或者 resolveClassMethod 在类中动态添加方法实现。如果没有实现，继续往下走。 快速转发，fast forwarding 在 forwardingTargetForSelector 该方法中会查找能够实现消息的新对象，如果没找到就返回nil，如果找到就返回这个新对象，消息的接受者也变成这个新对象。切记不可返回self，不然会死循环。 慢速转发，normal forwarding methodSignatureForSelector 根据SEL生成方法签名，封装了参数和返回值类型。如果methodSignatureForSelector返回nil，runtime就会发出doesNotRecognizeSelector消息。通过方法签名创建一个 NSInvocation 对象并发送 forwardingInvocation 消息给能处理消息的对象。 forwardingInvocation 中也没有对象可以处理该消息，就会调用 doesNotRecognizedSelector 抛出异常。 _objc_msgForward 是做什么的？直接调用会发生什么？ 这个主要用作消息转发。 _objc_msgForward 消息转发流程，整体流程同上。 如果直接调用 _objc_msgForward 会直接走转发流程，不会走查找方法缓存和寻找方法。 一个objc对象如何进行内存布局？测试对象图的结构 所有父类的成员变量和本类的成员变量都会存在该对象的存储空间中。 每一个对象内部都有一个isa指针，指向它的类对象，类对象又存放着本类的实例方法列表、成员变量列表、属性列表。 类对象本身内部也有一个isa指针，指向它的元对象，元对象内部存储着类方法列表。 类对象内部还有一个superclass指针，指向它的父类对象。 根对象是NSObject，它的superclass指针指向nil。 根元对象的superclass指向NSObject，isa指针指向自己。 讲一下对象，类对象，元类，跟元类结构体的组成以及他们是如何相关联的？为什么对象方法没有保存的对象结构体里，而是保存在类对象的结构体里？ 实例对象的 isa 指向类对象，类对象的 isa 指向元类，元类的 isa 指向根元类， 根元类的 isa 指向 自己。 iOS 中内省的几个方法？class方法和objc_getClass方法有什么区别? - (Class)class { return object_getClass(self); } Class object_getClass(id obj) { // 对象存在，获取对象isa指针指向的对象 if (obj) return obj->getIsa(); else return Nil; } Class objc_getClass(const char *aClassName) { if (!aClassName) return Nil; // NO unconnected, YES class handler return look_up_class(aClassName, NO, YES); } object_getClass 获取的是对象的isa指针所指向的对象 objc_getClass` 根据类名名称获取 Class 在运行时创建类的方法objc_allocateClassPair的方法名尾部为什么是pair（成对的意思）？ 这个方法的作用是动态创建类，因为类里面含有实例方法和类方法，实例方法是存放在类对象中，类方法是存放在元类中，所以其实创建新类是同时创建类和它的metaclass。所以尾部方法是pair成对的意思 load和initialize方法分别在什么时候调用的？ load 加载调用顺序 父类load -> 子类load -> 分类load 父类的 load 调用在子类的 load 调用之前。 分类的 load 在所有父类和子类 load 调用完成之后再调用。 分类的 load 调用不分子类和父类，根据 compile sources 中的顺序依次执行。 没有实现 load 方法就不调用。 load 中禁止调用super load，由系统加载，不需要手动调用。 initialize 在这个类接收第一条消息之前调用。 父 initialize 先于 子 initialize。 子没有实现 initialize，父的 initialize 会被调用。总共会被调用两次。 父类没有实现，只会调用子类的 initialize 方法。 任何父类或者子类的 category 都会覆盖父类或子类的 initialize 实现。 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:28:53 "},"Runtime/category.html":{"url":"Runtime/category.html","title":"分类","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 分类 分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？(考底层category实现方面) 分类 分类和扩展有什么区别？可以分别用来做什么？分类有哪些局限性？分类的结构体里面有哪些成员？(考底层category实现方面) https://techbird.me/2016/05/16/ios-category-use-merit-and-demerit/ https://tech.meituan.com/2015/03/03/diveintocategory.html 分类的作用：分类就是对类进行功能扩展。为现有的类添加新方法。 优缺点（局限性）： 把类的实现拆分到多个category文件中。 减少单个文件体积。 可以把不同功能组织到不同的category 按需加载需要的category 模拟多继承 把framework的私有方法公开。 category 缺点： 只能给某个已有的类添加方法，不能添加成员变量。 分类中可以添加属性，但是不能合成存取方法和成员变量。 如果分类中的方法和类中的方法同名，分类中的方法会覆盖掉原来类中的方法，所以避免这种情况一般分类中的方法都需要添加前缀。 如果多个分类存在同名方法，运行时调用哪个方法需要编译器确定。 category和extension的区别 extension 是一个匿名的 category，它属于类的一部分属于编译期确定，可以添加实例变量。 category 是在运行期决定的，无法添加实例方法，因为在运行期的时候对象的布局已经确定，如果添加实例变量会破坏类的内存布局。 3、category源码分析 typedef struct category_t { const char *name; //类的名字 classref_t cls; //类 struct method_list_t *instanceMethods; //category中所有给类添加的实例方法的列表 struct method_list_t *classMethods; //category中所有添加的类方法的列表 struct protocol_list_t *protocols; //category实现的所有协议的列表 struct property_list_t *instanceProperties; //category中添加的所有属性 } category_t; 所有的OC对象和类，在runtime底层都是结构体表示，category就是用category_t表示。 类的名字、类、给类添加的实例方法列表、所有类方法列表、所有协议列表、添加的所有属性。但是无法添加实例变量。 运行时，objc_class的大小是固定的，不能向这个结构体中添加数据，只能修改。ivars指向的是一个固定区域，只能修改成员变量的值，不能增加成员变量的个数。 methodLists是一个二维数组，可以修改*methodLists的值来添加成员变量方法。 4、 category如何加载 category 的加载是依赖 OC 的 runtime 的。 把 category 的实例方法、协议以及属性添加到类中。 把 category 的类方法和协议添加到类的 metaclass 中。 category 的方法没有完全替换掉原来类已经有的方法，类的方法列表中其实存在多个添加的方法。 category 的方法被放到前面，而原来类的方法被放到了后面，因为运行时在查找方法的时候是顺着方法列表查找的，一找到名字就罢休了。 5、category和关联对象 关联对象是存在什么地方呢？如何存储？对象销毁时如何处理关联对象？ 关联对象是由 AssociationsManager 管理，它的内部是由一个静态 AssociationsHashMap 来存储所有关联对象的，相当于存在一个全局map中。map的key是这个对象的指针地址，而value是另外一个associationsHashMap,里面保存了关联对象的kv对。 嗯，runtime的销毁对象函数objc_destructInstance里面会判断这个对象有没有关联对象，如果有，会调用_object_remove_assocations做关联对象的清理工作。 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:05:37 "},"Runtime/kvo.html":{"url":"Runtime/kvo.html","title":"KVO && KVC","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 KVO KVO的底层实现？如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？ 使用的坑 KVO KVO的底层实现？如何取消系统默认的KVO并手动触发（给KVO的触发设定条件：改变的值符合某个条件时再触发KVO）？ https://tech.glowing.com/cn/implement-kvo/ 原理 isa-swizzling 当被观察对象的属性值发生变化时，观察者对象就会收到通知。 KVO是基于runtime的isa-swizzling技术实现。为一个对象的属性设置观察者时，被观察的对象的isa指针会被修改，指向一个中间类，这个中间类是原来类的子类，重写了父类的setter方法，在重写的setter方法前后通知观察者对象值的改变，最后把这个isa指针指向新创建的类，对象也变成了新创建类的子类。 KVOController的源码分析 https://github.com/draveness/analyze/blob/master/contents/KVOController/KVOController.md https://satanwoo.github.io/2016/02/27/FBKVOController/ 使用的坑 必须在合适的时间，需要手动移除观察者，不然可能会引起crash。 注册观察者的代码和事件发生处的代码上下文不同，会分布在不同的方法中。 需要复写很长的方法，比较麻烦。 如果有多个观察属性，就需要在处理方法中进行if else的判断，可读性不高。 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:49:12 "},"Runtime/atomic.html":{"url":"Runtime/atomic.html","title":"atomic","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Atomic 讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？（多线程方面，底层atomic的实现） Atomic 讲一下atomic的实现机制；为什么不能保证绝对的线程安全（最好可以结合场景来说）？（多线程方面，底层atomic的实现） 使用atomic修饰的属性，编译器会默认设置读写方式为原子操作，并添加互斥锁进行保护。这把锁是os_fair_lock。 // 属性设置方法 id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) { // Atomic retain release world spinlock_t& slotlock = PropertyLocks[slot]; slotlock.lock(); id value = objc_retain(*slot); slotlock.unlock(); // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock. return objc_autoreleaseReturnValue(value); } 底层维护的一个属性锁数组，它的内部都是互斥锁，通过传入对象的哈希值来去数组中获取相应的互斥锁。 // 属性获取方法 static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) { if (!atomic) { oldValue = *slot; *slot = newValue; } else { spinlock_t& slotlock = PropertyLocks[slot]; slotlock.lock(); oldValue = *slot; *slot = newValue; slotlock.unlock(); } objc_release(oldValue); } Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:53:27 "},"Runtime/associate.html":{"url":"Runtime/associate.html","title":"关联对象","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Associated Object objc_setAssociatedObject AssociationsManager AssociationsHashMap ObjectAssociationMap ObjcAssociation objc_getAssociatedObject objc_removeAssociatedObjects 小结 引用 Associated Object 首先 runtime 为我们提供了三个关联对象的三个方法： id objc_getAssociatedObject(id object, const void *key); void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy); 三个方法的作用分别是： 根据 key 获取关联对象。 以键值对的形式添加关联对象。 移除所有关联对象。 objc_setAssociatedObject 首先是 objc_setAssociatedObject 方法 void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) { _object_set_associative_reference(object, (void *)key, value, policy); } 内部调用 _object_set_associative_reference 来完成关联对象的设置 void _object_set_associative_reference(id object, void *key, id value, uintptr_t policy) { { AssociationsManager manager; AssociationsHashMap &associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); if (new_value) { if (i != associations.end()) { ObjectAssociationMap *refs = i->second; ObjectAssociationMap::iterator j = refs->find(key); } } } } 上述的源代码可以发现几个新的类和数据结构： AssociationsManager AssociationsHashMap ObjectAssociationMap ObjectAssociation 我们来先看看这几个类或数据结构到底是用来干什么的？ AssociationsManager AssociationsManager在代码中的定义如下： spinlock_t AssociationsManagerLock; class AssociationsManager { // associative references: object pointer -> PtrPtrHashMap. static AssociationsHashMap *_map; public: AssociationsManager() { AssociationsManagerLock.lock(); } ~AssociationsManager() { AssociationsManagerLock.unlock(); } AssociationsHashMap &associations() { if (_map == NULL) _map = new AssociationsHashMap(); return *_map; } }; 它维护着 AssociationsHashMap 和 AssociationsManagerLock 两个单例。AssociationsManagerLock 是一个互斥锁。 初始化的时候加锁，析构的时候解锁。 通过 associations() 方法获取一个全局的 AssociationsHashMap。 使用锁的机制来保证对 AssociationsHashMap 的操作是线程安全的。 AssociationsHashMap AssociationsHashMap 的类型声明如下： typedef hash_map AssociationsHashMap; 它是一个散列表，是以 disguised_ptr_t 为键，ObjectAssociationMap 类型实例为值的映射方式来保存对象。 ObjectAssociationMap ObjectAssociationMap 的类型定义如下： typedef hash_map ObjectAssociationMap; 保存了从 key 到 ObjcAssociation 的映射，这个数据结构保存了当前对象对应的所有关联对象。 ObjcAssociation class ObjcAssociation { uintptr_t _policy; id _value; public: ObjcAssociation(uintptr_t policy, id value) : _policy(policy), _value(value) {} ObjcAssociation() : _policy(0), _value(nil) {} uintptr_t policy() const { return _policy; } id value() const { return _value; } bool hasValue() { return _value != nil; } }; 该对象内包含了 policy 和 value。 现在我们重新来看 objc_setAssociatedObject 的具体实现，我们使用一张流程图表示： 这边有两种情况： new_value != nil，添加和更新关联对象。 new_value == nil，删除一个关联对象。 设置关联对象 // create the new association (first time). ObjectAssociationMap *refs = new ObjectAssociationMap; associations[disguised_object] = refs; (*refs)[key] = ObjcAssociation(policy, new_value); object->setHasAssociatedObjects(); 更新关联对象 // secondary table exists ObjectAssociationMap *refs = i->second; ObjectAssociationMap::iterator j = refs->find(key); if (j != refs->end()) { old_association = j->second; j->second = ObjcAssociation(policy, new_value); } else { (*refs)[key] = ObjcAssociation(policy, new_value); } 删除关联对象 AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i->second; ObjectAssociationMap::iterator j = refs->find(key); if (j != refs->end()) { old_association = j->second; refs->erase(j); } } 使用 old_association 创建一个临时的 ObjcAssociation 对象。 通过 acquireValue 函数对 new_value 进行 retain 或 copy 操作。 初始化一个 AssociationsManager，获取唯一关联对象的哈希表 AssociationsHashMap。 先使用 DISGUISE(object) 作为 key 寻找对应的 ObjectAssociationMap。 如果没找到，初始化一个 ObjectAssociationMap，再实例化 ObjcAssociation 对象添加到 map 中。并调用 setHasAssociatedObjects 表明当前对象含有关联对象。 如果找到对应 ObjectAssociationMap，就看 key 是否存在，来决定是更新原有的关联对象还是增加一个。 到最后原来的关联对象有值的话，会调用 ReleaseValue 释放关联对象的值。 objc_getAssociatedObject id _object_get_associative_reference(id object, void *key) { id value = nil; uintptr_t policy = OBJC_ASSOCIATION_ASSIGN; { AssociationsManager manager; AssociationsHashMap &associations(manager.associations()); disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { ObjectAssociationMap *refs = i->second; ObjectAssociationMap::iterator j = refs->find(key); if (j != refs->end()) { ObjcAssociation &entry = j->second; value = entry.value(); policy = entry.policy(); if (policy & OBJC_ASSOCIATION_GETTER_RETAIN) { objc_retain(value); } } } } if (value && (policy & OBJC_ASSOCIATION_GETTER_AUTORELEASE)) { objc_autorelease(value); } return value; } 获取全局的哈希表 AssociationsHashMap 通过 DISGUISE(object) 为key，获取哈希表中存储对应的 ObjectAssociationMap。 以 void *key 为 key 查找 ObjcAssociation。 根据 policy 进行相应的内存管理。 if (policy & OBJC_ASSOCIATION_GETTER_RETAIN) { objc_retain(value); } if (value && (policy & OBJC_ASSOCIATION_GETTER_AUTORELEASE)) { objc_autorelease(value); } 5、最后返回关联对象的值。 objc_removeAssociatedObjects void objc_removeAssociatedObjects(id object) { if (object && object->hasAssociatedObjects()) { _object_remove_assocations(object); } } 会先通过 hasAssociatedObjects 来判断是否有关联对象。没有则调用结束。 调用_object_remove_assocations方法。 void _object_remove_assocations(id object) { vector > elements; { AssociationsManager manager; AssociationsHashMap &associations(manager.associations()); if (associations.size() == 0) return; disguised_ptr_t disguised_object = DISGUISE(object); AssociationsHashMap::iterator i = associations.find(disguised_object); if (i != associations.end()) { // copy all of the associations that need to be removed. ObjectAssociationMap *refs = i->second; for (ObjectAssociationMap::iterator j = refs->begin(), end = refs->end(); j != end; ++j) { elements.push_back(j->second); } // remove the secondary table. delete refs; associations.erase(i); } } // the calls to releaseValue() happen outside of the lock. for_each(elements.begin(), elements.end(), ReleaseValue()); } 获取全局 AssociationsHashMap。 判断哈希表大小是否为 0。 以 DISGUISE(object) 为 key 查找 ObjectAssociationMap。 查找到所有关联对象，存放在 elements 中。 最后 elements 中的对象调用 ReleaseValue，释放所有不需要的值。 小结 关联对象其实就是 ObjcAssociation 对象。 关联对象由 AssociationsManager 管理并在 AssociationsHashMap 存储。 对象的指针及其对应的 ObjectAssociationMap 以键值对的形式存储在 AssociationsHashMap 中。 ObjectAssociationMap 则是用于存储关联对象的数据结构。 每个对象都有一个标记为 has_assoc 表示对象是否含有关联对象。 引用 https://draveness.me/ao Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:02:22 "},"runloop/":{"url":"runloop/","title":"Runloop","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Runloop 参考 说一下 Runloop 和线程的关系 Runloop 有几种 mode Runloop Observer 的状态，Runloop 的内部实现？ RunLoop的作用是什么？它的内部工作机制了解么？（最好结合线程和内存管理来说） Runloop 有关的内容 NSNotificationCenter是在哪个线程发送的通知？ Runloop 使用的坑 Runloop 参考 https://blog.ibireme.com/2015/05/18/runloop/ http://southpeak.github.io/2015/03/14/nsnotification-and-multithreading/ 说一下 Runloop 和线程的关系 runloop 跟线程的关系是一一对应关系，如果没有线程，runloop也没有存在的必要。主线程的runloop会自动创建，子线程的runloop需要手动创建。 Runloop 有几种 mode NSRunLoopDefaultMode，App默认 mode，主线程就是运行在该 mode 下。 UITrackingRunloopMode，界面跟踪 mode，当滑动 UIScrollView 的时候，defaultMode 就会切换到 UITrackingMode。 UIInitializationRunloopMode，App 启动的时候获取的第一个 mode，启动完成后不再使用。 GSEventReceiveRunloopMode，接收系统内部事件，不经常使用。 kCFRunLoopCommonModes 占位 mode，common 属性，runloop 内容发生变化时，会自动把commonModes 里面的 source、observer、timer 同步到具有 common 属性的 mode 中。 Runloop Observer 的状态，Runloop 的内部实现？ Observer 的状态： entry beforeTimer beforeSource beforeWaiting AfterWaiting exit RunLoop的作用是什么？它的内部工作机制了解么？（最好结合线程和内存管理来说） 内部的本质其实就是一个do-while循环。核心是基于mach port的。 1、首先根据modeName找到对应的mode，如果mode中没有source、timer、observer，会直接返回。 2、通知observer，runloop即将进入loop、 3、通知observer，runloop即将触发timer回调。 4、通知observer，runloop即将触发source0回调。 5、触发source0回调 6、如果有source1，直接处理这个source1，然后跳转去处理消息。 7、通知observer，runloop即将进入休眠。 8、线程即将进入休眠，直到被下面某个事件唤醒。 一个基于port的source事件。 一个timer时间到了 runloop自身超时时间到了 被其他调用者手动唤醒。 9、通知observer，runloop的线程刚刚被唤醒。 10、通知observer，runloop即将退出。 Runloop 有关的内容 1、autorelease 释放相关 APP启动后，apple会在主线程注册两个observer，第一个observer监听的事件是entry，其回调会调用_objc_autoreleasePoolPush()创建自动释放池，优先级最高，保证在所有回调之前。 第二个observer监听两个事件，beforeWaiting时调用_objc_autoreleasePoolPop() 和 _objc_autoreleasePoolPush() 释放旧的池并创建新池。exit 时调用 _objc_autoreleasePoolPop() 来释放自动释放池，这个优先级最低，保证所有回调之后。 关于事件响应 apple 会注册一个 source1 用来接收系统事件，如果有事件发生，就会触发source1的回调函数，被事件封装成UIEvent进行分发，包括手势识别、屏幕旋转、按钮点击等等。 关于手势识别 当识别一个手势的时候，会先 cancel 当前 touchbegin 等事件回调，将手势识别器标记为待处理，apple 注册的 observer 监听 beforWaiting 事件，回调函数就会获取内部被标记的待处理手势，然后执行。 关于界面更新 当操作 UI 时，所有的改动，都被标记为待处理，并提交到一个全局容器中。apple注册了一个observer监听beforeWaiting和exit事件，回调函数内去遍历所有待处理的绘制和布局事件，去更新UI。 2、定时器 一个NSTimer注册到runloop后，Runloop会为其重复的时间点注册事件，为了节省资源，不会再准确的时间节点回调这个timer。 3、performSelector 其实当我们调用 performSelecter:afterDelay 和 performSelector:onThread 方法时，实际都会创建一个timer放到runloop中，如果当前线程没有runloop，则这个方法不会被执行。 4、关于GCD 只有调用 dispatch_async 时，libDispatch 才会向主线程发送runloop消息，runloop会被唤醒，并在回调里执行这个block。 5、关于网络请求 AFNetworking 2.x 版本的时候，内部还使用runloop来进行线程保活，因为NSURLConnection 的设计，当发送请求后，必须让线程保活来接收 connection delegate 回调回来的数据，所以设计了使用NSRunloop来进行线程保活。 NSNotificationCenter是在哪个线程发送的通知？ 它是一个线程安全类，可以在多线程环境下使用同一个 NSNotificationCenter 对象而不需要加锁。 但是在多线程环境中，NSNotificationCenter 的 post 和转发 是在同一个线程中。 Runloop 使用的坑 1、UIScrollView 在滚动的过程中，为什么 NSTimer 会暂停？ 2、performSelecter:afterDelay 使用的过程中，selector 为什么没有被调用？ 3、如果使用 Runloop 创建一个常驻线程？ 4、如何使用 Runloop 来监听主线程的卡顿？ Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:56:48 "},"design/":{"url":"design/","title":"设计模式","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 设计模式 除了单例，观察者设计模式以外，还知道哪些设计模式？分别介绍一下 最喜欢哪个设计模式？为什么? iOS SDK 里面有哪些设计模式的实践？ 设计模式是为了解决什么问题的？ 设计模式的成员构成以及工作机制是什么? 设计模式的优缺点是什么？ App 应用签名 App 应用重签名 设计模式 除了单例，观察者设计模式以外，还知道哪些设计模式？分别介绍一下 http://yoferzhang.com/post/20171123CocoaDesignPatterns/ 对象创建：原型、工厂、抽象工厂、单例、生成器 工厂方法：定义创建对象的接口，让子类决定实例化哪一个类，工厂方法使得一个类的实例化延迟到子类。 抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类。 单例：保证类只有一个实例，并提供一个访问它的全局访问点。 接口适配：适配器、桥接、外观 适配器：将一个类的接口转换为客户端需要的另外一个接口，适配器模式使得原本接口不兼容而不能工作的那些类可以一起工作。 桥接：将抽象部分和它的实现部分分离，使得它们可以独立变化。 外观：为系统中的一组接口提供一个统一的接口，外观定义一个高层接口，让子系统更加易于使用。 对象解耦：观察者、中介者 中介者：用一个对象封装一系列对象的交互方式，中介者使各对象不需要显示的互相引用，从而使其耦合松散，而可以独立改变他们之间的交互。 观察者：定义对象的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖他的对象都得到通知并被自动更新。 对象抽象：组合、迭代器 行为扩展：访问者、装饰者、责任链 算法封装：模板、策略、命令 性能和对象访问：代理 最喜欢哪个设计模式？为什么? 抽象工厂，外观，观察者，装饰者，代理。 装饰器。代理和分类，在实际的开发过程中，可以利用分类和delegate进行对象解耦。 iOS SDK 里面有哪些设计模式的实践？ NSNumber的抽象工厂，类簇。 适配器，协议，例如UITableViewDelegate 命令模式，Target-Action，NSInvocation---- 观察者，KVO、NSNotification 单例，UIApplication，NSFileManager等等。 设计模式是为了解决什么问题的？ 让程序更加易扩展。 设计模式的成员构成以及工作机制是什么? ... 设计模式的优缺点是什么？ ... App 应用签名 数字签名如下： App 双重签名： Mac 自己生产 公钥M 和 私钥M。 苹果的 公钥A在 iOS 设备上，私钥A 在后台。 把 Mac的 公钥M 上传给苹果后台，苹果后台用 私钥A 去签名公钥M，得到一份数据包含公钥和数字签名，这份数据也叫证书（公钥M+摘要）。 生成描述文件 Provisioning Profile 内部有证书 + Entitlements（设备列表+APPID+权限）。 App进行打包时，通过 私钥M 对App进行签名，把证书(公钥M+数字摘要)同时打包进App。 在安装时，iOS系统得到证书，用系统内置的 公钥A 去验证证书，获取到公钥L，让后使用公钥L去验证App的签名，验证设备ID是否在列表上。 几个概念： p12：私钥L csr：公钥L 证书：公钥L+数字摘要 entitlements：权限+设备ID+AppID Provisioning Profile：证书 + entitlements。 App 应用重签名 https://juejin.im/post/5c460908f265da6167209b87 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:06:57 "},"design/architecture.html":{"url":"design/architecture.html","title":"架构","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 架构 MVC和MVVM的区别？MVVM和MVP的区别？ 面向对象的几个设计原则了解么？最好可以结合场景来说。 可以说几个重构的技巧么？你觉得重构适合什么时候来做? 你觉得框架和设计模式的区别是什么？ 看过哪些第三方框架的源码，它们是怎么设计的？设计好的地方在哪里，不好的地方在哪里，如何改进？（这道题的后三个问题的难度已经很高了，如果不是太N的公司不建议深究） 架构 MVC和MVVM的区别？MVVM和MVP的区别？ 面向对象的几个设计原则了解么？最好可以结合场景来说。 单一原则 开闭原则 里氏替换原则 接口分离原则 依赖倒置原则 迪米法特原则 可以说几个重构的技巧么？你觉得重构适合什么时候来做? 重构的技巧： 重复代码的提取 过长的函数，一个函数中做了好多事情 过长的参数列表，可以把这些参数整理到一个对象中，使用这个对象进行传递。 重构的时机：我们应该随时随地的进行，比如添加新功能时，发现无法扩展时；修改bug和线上crash的时候；code review的时候； 你觉得框架和设计模式的区别是什么？ 看过哪些第三方框架的源码，它们是怎么设计的？设计好的地方在哪里，不好的地方在哪里，如何改进？（这道题的后三个问题的难度已经很高了，如果不是太N的公司不建议深究） Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:16:18 "},"network/":{"url":"network/","title":"网络题","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 网络题 POST和GET请求的区别 OSI模型和TCP/IP模型 TCP/IP的区别 TCP为什么要三次握手，四次挥手？ 对称加密和非对称加密的区别？分别有哪些算法的实现？ HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么? 如何用Charles抓HTTPS的包？其中原理和流程是什么？ 什么是中间人攻击？如何避免？ App 网络层有哪些优化策略？ 说一下HTTP协议以及经常使用的code码的含义。 网络题 POST和GET请求的区别 总共从三个方面来说明： 请求资源位置。GET的请求参数放在QS中，POST放在body中。 长度限制。GET的URL会根据游览器的长度限制，POST在body中无限制。 安全性。POST相对于GET请求安全性更高一些。 OSI模型和TCP/IP模型 OSI模型从下至上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。 TCP/IP模型从下至上：硬件、数据链路层、网络层、传输层、应用层。 网络层协议：IP协议 传输层：TCP UDP 应用层：HTTP HTTPS FTP TCP/IP的区别 TCP 是有连接，字节流协议。UDP 是无连接的数据报协议。 TCP 连接需要握手，确定通信双方，不适用于多播和广播。UDP 发送数据之前不需要握手，适用于广播。 TCP 有确认应答、顺序控制、重传机制，比较可靠。UDP 没有重传机制，会经常丢包也会多次达到，缺乏可靠。 TCP为什么要三次握手，四次挥手？ 三次握手： 第一次握手(SYN=1, seq=x): 客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。 发送完毕后，客户端进入 SYN_SEND 状态。 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1): 服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入 SYN_RCVD 状态。 第三次握手(ACK=1，ACKnum=y+1) 客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1 发送完毕后，客户端进入 ESTABLISHED 状态，当服务器端接收到这个包时，也进入 ESTABLISHED 状态，TCP 握手结束。 四次挥手 刚开始双方都处于ESTABLISHED（已确定）状态，加入客户端先发起挥手。 第一次挥手(FIN=1，seq=x) 假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。 发送完毕后，客户端进入 FIN_WAIT_1 状态。 第二次挥手(ACK=1，ACKnum=x+1) 服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。 发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 第三次挥手(FIN=1，seq=y) 服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。 发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 第四次挥手(ACK=1，ACKnum=y+1) 客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 对称加密和非对称加密的区别？分别有哪些算法的实现？ 对称加密算法，是甲乙双方使用同一种加密规则，加解密使用相同的秘钥，安全性不高，但是速度快。例如：AES。 非对称加密算法，是甲乙双方使用一对秘钥，分为公钥和私钥，客户端使用公钥对传输内容进行加密，服务端使用私钥对内容解密。安全性稍微高一点。例如：RSA。 HTTPS的握手流程？为什么密钥的传递需要使用非对称加密？双向认证了解么? HTTPS是身披SSL外壳的HTTP。 HTTPS = HTTP + 加密 + 认证 + 完整性验证 HTTPS采用混合加密机制。就是共享密码加密和公开秘钥加密的混合加密方式。 使用公开秘钥加密也是存在问题的，如何证明公开密钥就是服务端发行的公开密钥。为了解决这个问题，可以使用数字证书认证机构和其相关颁发的公开密钥证书。 数字认证机构会对服务端的公开密钥进行数字签名，然后将这个公钥放入公钥证书中，服务端就将这个证书发送给客户端。 客户端接收到数字证书后，使用数字认证结机构的公开密钥，对这张证书上的数字签名进行验证。 HTTPS的安全通信机制（单向认证）： 客户端发送clientHello给后端，报文中包含客户端支持的SSL协议版本，加密组件列表。发起HTTPS请求。 后端可SSL通信时，会以ServerHello报文作为应答，报文中包含SSL版本和加密组件，这个组件是从客户端的列表中选出来的。 后端从数字认证机构申请数字证书（包括服务端公钥和签名），后端发送Certi报文，报文中包含公开秘钥证书。 最后服务端发送ServerhelloDone，通知客户端SSL握手协商部分结束。 客户端通过CA公钥，采用相同hash散列函数计算信息摘要，通过CA公钥去解密签名，证明证书的可信，然后取出服务端公钥。 客户端发送ClientKeyExchange报文给后端，报文中包含一个随机加密码。 客户端发送changeCipherSpec报文，提示后端之后会以这个随机加密秘钥加密。 客户端发送Finished报文。 后端使用秘钥去解密这个随机数，得要随机数。 后端同时也会发送changeCipherSpec 和Finished 报文，SSL链接就算完成。 双向认证： 客户端发送clientHello，报文含有客户端支持的SSL版本、加密组件。 后端发送ServerHello回应，报文中包含SSL版本和加密组件。 后端申请数字证书，后端发送Certificate报文，报文中含有服务端公钥。 后端发送ServerHelloDone，告知SSL握手协议结束。 客户端拿到CA公钥，通过hash散列函数计算得到信息摘要，然是通过CA公钥去解密签名，对比信息摘要，如果一致获取后端公钥。 客户端发送客户端证书给服务端，证书中含有客户端公钥 客户端发送支持的加密组件给服务端，供其选择。 后端选择加密组件后，用刚才的客户端公钥去加密选好的加密方案 客户端使用自己的私钥去解密选好的加密方案，客户端使用一个随机数，用刚得到的服务端公钥去加密这个随机数形成密文，发送给服务端。 如何用Charles抓HTTPS的包？其中原理和流程是什么？ 常用的抓包工具的抓包方式都是使用中间人，对客户端伪装成服务端，对服务端伪装成客户端。 截获客户端的请求，伪装成中间人客户端去访问HTTPS请求。 接受服务端返回，伪装成中间人服务端向客户端发送数据。 1、当客户端向服务端发送Https请求时，后端会将服务端公钥和前面发送给客户端，此时charles截获通过CA公钥完成验证，获取到服务端公钥，然后通过自己的证书替换掉服务端的证书发送给客户端。 2、客户端接收到charles证书，通过charles root证书解密获取到charles公钥，然后使用公钥去加密随机数，发送到charles时，用charles私钥解密获取随机数，然后使用服务端公钥加密改随机数然后返回给后端。 什么是中间人攻击？如何避免？ 中间人攻击主要是，中间人伪造一张服务端证书给客户端，让客户端觉得这是一张正确的证书。 采用SSL-Pinning，一般有两种方式： 证书锁定：需要在客户端代码内置仅接受指定域名的证书，不接受游览器或操作系统内置的CA根证书对应的任何证书，这种方案存在有效期问题，需要在证书快要过期之前重新内置到app内。 公钥锁定：提取证书中的公钥并内置到客户端中，通过对比服务端的公钥值来验证。 App 网络层有哪些优化策略？ https://www.jianshu.com/p/fcf5c2add9e0 http://mrpeak.cn/blog/ios-network/ https://tech.meituan.com/2017/03/17/shark-sdk.html DNS映射。 合理的并发数。 请求合并。 请求的安全性。 网络环境监测。 请求成功率监测。 说一下HTTP协议以及经常使用的code码的含义。 200、204：请求被正常处理了。 300：重定向 400：客户端的请求错误，请求报文中出现错误语法。 404：服务器上无法找到请求资源。 500：服务器内部错误。 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:04:37 "},"multiThread/":{"url":"multiThread/","title":"多线程","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 多线程 线程的生命周期 说一下线程之间的通信？ NSThread、NSOPerationQueue、GCD 区别 GCD 什么时候会出现死锁？如何避免？ 说一说你对线程安全的理解？ 列举你知道的线程同步策略？ 有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说 dispatchbarrierasync 的作用 多线程 线程的生命周期 四个状态： 就绪态 运行态 阻塞态 死亡态 创建线程对象并启动属于就绪态，通过CPU的调度在运行态和就绪态之间切换，如果有锁就会成为阻塞态，诚信执行完毕后变为死亡态。 说一下线程之间的通信？ 1、假设两个线程A和B同时访问一个资源C，为了防止资源抢夺，A在读取C的时候加锁，然后读取完成修改吧数据写入C，最后解锁。在线程A对C操作时，B是无法访问的，只有A解锁之后，B才能访问资源。 2、下载图片，一般都是在子线程下载完成后，切换到主线程进行渲染。 简单一点的说 防止多线程抢夺资源造成的数据安全问题 一个线程处理完数据传递给另一个线程 一个线程处理完特定任务后，切换到另一个线程继续执行任务。 线程相关使用的类 NSOject PerformSelectorOnMainThread NSThread NSOperation && NSOperationQueue GCD NSThread、NSOPerationQueue、GCD 区别 NSThread 需要维护自己的生命周期，是基于pthread 封装的OC类，线程之间的并发需要自己控制。 NSOperation 它是基于GCD封装的抽象类，实际使用中需要使用它的子类，它不需要管理线程的生命周期和线程的同步和互斥。还可以设置任务之间的依赖关系等等。 GCD 是apple提出解除多线程问题的一个解决方案。使用起来简单。 NSOperation vs GCD GCD是基于底层C的API，Queue是OC对象类。并且其实实现使用GCD。 GCD的使用比较轻量；Operation的使用比较复杂。 Operation控制比GCD好，可以控制操作队列的暂停、取消和回复。 Operation可是设置两个操作之间的依赖。 Operation可以监视操作或操作队列的状态。准备、执行或完成。 Operation可以指定可以同时运行的队列操作的最大数目，可以控制最大并发数。 GCD GCD的几个重要概念 1、队列 queue。分为串行队列和并行队列。 2、任务 sources，可以把source创建到系统上。 3、分组 group，可以把一系列任务加到分组中，等待组中的所有任务完成才结束。 4、信号量 semaphores，控制更加复杂的并发。 Queue，执行顺序 FIFO 1、串行队列。队列中的任务一个接一个的执行，顺序执行。 2、并行队列。可以并发的执行多个任务。 3、主队列，是一个全局的串行队列，任务会在主线程中执行，主队列通过与runloop交互，把任务添加到runloop中执行。 Global Queue 队列优先级 High、Default、Low、Background 执行任务 1、async。异步执行，不用等待之前的任务是否已完成，可以立即开始新的一个任务。 2、sync。同步执行，任务执行完一个再执行下一个。 线程安全 1、GCD本身是线程安全的。把任务加入到队列中不用考虑锁。 2、避免在队列中使用锁。 经典问题 1、在主队列中同步执行。死锁。 2、在全局并行队列中同步执行，不会死锁。 3、在自定义的串行队列中同步执行，死锁。 4、在全局并发队列中异步执行，然后在主线程中同步执行，正常。 什么时候会出现死锁？如何避免？ 互斥锁解决了竞态条件问题，但是还有一个问题是死锁。当多个线程都互相等待着对方接受时，就会发生死锁。 减少线程间资源管理，并确保共享的资源尽量简单。 说一说你对线程安全的理解？ 如果多线程里访问一个共享资源，两个并发线程A和线程B同时写入和读取数据，会产生资源竞争问题。如果没有一种互斥机制来保证在多线程环境下访问共享资源。问题很难避免。 属性声明的atomic，讲一个属性声明为atomic表示每次访问改属性都会进行隐式的加锁和解锁操作。 列举你知道的线程同步策略？ 1、锁 2、串行队列 3、信号量 有哪几种锁？各自的原理？它们之间的区别是什么？最好可以结合使用场景来说 https://www.zybuluo.com/qidiandasheng/note/493337 https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/ 1、OSSpinLock（自旋锁）。 2、NSLock（对象锁）。 3、pthread_mutex（互斥锁）。 4、@synchronized（对象锁）。 5、NSCondition 6、NSRecursiveLock（递归锁）。 7、串行队列 8、dispatch_semaphore（信号量） 9、os_unfair_lock 实际场景：线程A 和 线程B OCSpinLock，自旋锁加锁，A持有锁，B就会处于忙等状态，检查锁是否可用，消耗CPU资源。优先级反转问题，A的优先级低正在持有锁，B的优先级高，所以A不敢跟B抢资源，导致A迟迟不能完成任务，也无法释放锁。 pthred_mutex_t，互斥锁加锁，A持有锁，B处于休眠状态，A释放锁，B访问，不会占用CPU资源。 os_fair_lock 代替 OCSpinLock，跟互斥锁一个性质。 NSRecursiveLock，递归锁，A持有锁，然后反复加锁持有锁，不会导致死锁。 NSLock，对象锁。 NSConditionLock 条件锁，A会在满足条件的前提下才会获得锁。 dispatch_barrier_async 的作用 在并发队列中，为了保持某些任务的顺序，需要等待一些任务完成后才能继续执行。通过barrier_async向并发队列中追加任务时，必须等并发队列之前的任务完成后，然后只想这个追加任务，执行完这个追加任务再继续指向后面的任务。 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:52:02 "},"datastruct/":{"url":"datastruct/","title":"数据结构","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 数据结构 链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？ 哈希表是如何实现的？如何解决地址冲突？ 排序题：冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？ 链表题：如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？ 数组题：如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？ 二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？ 数据结构 链表和数组的区别是什么？插入和查询的时间复杂度分别是多少？ 数组是一块连续的内存。随机访问性强，查找速度快。插入和删除效率低，可能浪费内存，内存空间要求高，必须有足够的连续内存空间。插入和删除是On，查询是O1 链表插入删除速度快，内存利用率高，不浪费内存，大小没有固定，容易扩展。插入和删除是O1，查询是On 哈希表是如何实现的？如何解决地址冲突？ 。。。 排序题：冒泡排序，选择排序，插入排序，快速排序（二路，三路）能写出那些？ https://www.cnblogs.com/onepixel/p/7674659.html 。。。 链表题：如何检测链表中是否有环？如何删除链表中等于某个值的所有节点？ 。。。 数组题：如何在有序数组中找出和等于给定值的两个元素？如何合并两个有序的数组之后保持有序？ 。。。 二叉树题：如何反转二叉树？如何验证两个二叉树是完全相等的？ 。。。 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:09:50 "},"system/":{"url":"system/","title":"系统原理","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 系统原理 了解编译的过程么？分为哪几个步骤？ 静态链接和动态链接的区别 静态链接了解么？静态库和动态库的区别? 内存的几大区域，各自的职能分别是什么？ static和const有什么区别？ 了解内联函数么？ 系统原理 了解编译的过程么？分为哪几个步骤？ iOS使用的是编译器LLVM，编译前端是Clang，编译后端是LLVM。LLVM是编译器工具链技术的一个集合，其中的lld就是内置链接器，编译器对每个文件进行编译生成mach-O，链接器把多个mach-O合成一个mach-O。 编译的几个重要过程： 1、预处理，LLVM会预处理代码，将代码中的宏用其定义的内容进行替换。 2、LLVM会对代码进行词法分析，代码文本都会被转成特殊的token标记。 3、LLVM会对代码进行语法分析，生成AST抽象语法树，使用AST能够快速的进行静态检查，同时还能生成中间代码IR。 4、静态分析，编译器会对AST做分析，找出代码错误，比如类型检查，对象是否实现某个方法。 5、类型检查分为动态和静态，静态在编译时做检查，动态检查在运行时做检查。 6、代码生成LLVM，然后进行优化。 7、最后AST生成IR，是一种接近机器码的语言，和平台无关。通过IR可以生成多份适合不同平台的机器码。 预处理 符号化 (Tokenization) 宏定义的展开 include 的展开 语法和语义分析 将符号化后的内容转化为一棵解析树 (parse tree) 解析树做语义分析 输出一棵抽象语法树（Abstract Syntax Tree* (AST)） 生成代码和优化 将 AST 转换为更低级的中间码 (LLVM IR) 对生成的中间码做优化 生成特定目标代码 输出汇编代码 汇编器 将汇编代码转换为目标对象文件。 链接器 将多个目标对象文件合并为一个可执行文件 (或者一个动态库) 静态链接和动态链接的区别 静态链接就是把符号绑定到内存地址上。经过编译之后，每个源文件都会被编译成.o文件，最后通过链接器合成一个Mach-O文件，在链接的过程中会创建一个符号表，把所有定义的和未定义的的所有符号记录在符号表中。 简单的回答就是：扫描所有目标文件，收集所有符号和引用地址存放到一个符号表中，然后计算合并后的长度和位置，将相同段内的符号进行合并，进行绑定。对不同文件内的符号进行地址重定位。 动态链接主要是针对动态库，动态库是共享的。动态库是在运行时由dyld进行动态链接，所以不会参与到Mach-O 文件的编译，目标文件内对动态库的引用的符号是未定义的，他们的名字和对应的库会被记录下来，通过dlopen打开动态库返回的就是引用的指针，dlsysm 会通过返回的函数符号得到对应的地址。 根据Mach-O未定义的符号加载对应的动态库，系统会提供一个共享链接库来提升连接速度，将符号绑定到动态库里对应的地址上。 静态链接了解么？静态库和动态库的区别? 链接器最主要的作用，将符号绑定到地址上。LLVM对每个文件进行编译生成Mach-O，Mach-O里面主要是代码和数据。代码是函数的定义，数据是全局变量的定义，包括全部变量的初始化。 链接器的作用，就是完成变量、函数符号和其他地址绑定的任务。链接器在链接多个目标文件的过程中，会创建一个符号表，用于记录所有已定义的和所有未定义的符号。 链接器做的事情： 去项目文件里查找目标代码文件中没有定义的变量。 扫描项目的不同文件，将所有符号定义和引用地址收集寄来，并放到全局符号表中。 计算合并后长度和位置，生成同类型段的进行合并，建立绑定。 对项目中不同文件里的变量进行地址重定位。 静态库 .a 和 .framework 动态库 .dylib 和 .framework 在链接阶段，静态库会被完整的复制到可执行文件中，被多次使用就会有多份冗余拷贝。动态库在链接时不会复制，由系统加载到内存中，供程序使用，系统只加载一次，多个程序共用，节约内存。 内存的几大区域，各自的职能分别是什么？ 栈区stack。由编译器自动分配内存，程序结束时自动释放。存放函数调用过程中的各种参数、局部变量、返回值以及函数返回地址。先进后出，程序员无法控制。 堆区heap。在内存上开辟另外一块存储区域，程序员主动申请和释放内存，如果程序员不主动释放，程序结束由系统释放。 全局存储区，也叫静态存储区。分为DATA段和BSS段。DATA段是全局初始化区，存放初始化的全局变量和静态变量。BSS段是全局未初始化区，存放未初始化的全局变量和静态变量。程序运行结束后自动释放，BSS段在程序执行之前会被系统自动清0. 文字常量区。存放常量字符串，只读状态，不可修改，程序结束后由系统释放。 程序代码区。存放程序的二进制代码。 static和const有什么区别？ static 修饰的变量和函数会被延长生命周期，被修饰的类型会保存在bss端，内存由编译器分配，一般程序结束后清除释放。限制其作用域，只在其声明的源文件中有效。 const 修饰的数据是常量，不可被修改。位于常量区，可以修饰全局变量和局部变量，修饰全局变量时，外部不可访问并且进行修改，局部常量也不可修改。 extern 声明外部全局变量，只能用于声明，不能用于实现。用其声明外部全局变量或常量。 了解内联函数么？ 内联函数和的效率和宏变量差不多，但是可靠性比宏定义好很多。可以设置断点、类型检查和避免异常行为。 内联函数也叫编译器扩展函数，就是在编译器的时候将函数体插入并取代每一处调用该函数的上下文。从而节省每次调用函数的额外开支。 类型检查，宏不进行类型检查。内联函数可以进行类型检查和避免异常行为。 宏只是文本替换。 内联函数可以设置断点，进行调试。 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 20:42:48 "},"performance/":{"url":"performance/","title":"性能优化","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 性能优化 说一下UITableViewCell的卡顿你是怎么优化的？ 渲染流程 离屏渲染产生原因 首页启动优化 性能优化 说一下UITableViewCell的卡顿你是怎么优化的？ CPU 重用 cell。 缓存 cell 高度。 异步计算每个 cell 的高度，缓存高度。 减少视图的添加和移除，使用 hidden 操作。 使用纯代码布局。 异步加载图片，图片在后台线程进行解码，resize 图片大小。 尽量把耗时任务放到子线程中处理。 GPU 减少图层数。opaque = YES。 减少离屏渲染。 采用特殊图层进行渲染。 图片过多可使用 Core Graphics 进行图片合成。 渲染流程 Layout Display Prepare Commit 离屏渲染产生原因 cornerRadius + maskToBounds shadow mask shouldRasterize 首页启动优化 从点击 App 图标开始到首页渲染显示出来的整个过程。总共分为三个阶段： main 函数执行前。 main 函数执行后。 首屏渲染后。 main 函数执行前（dyld -> rebase -> bind -> objc setup -> initialize）: 加载可执行文件。 加载动态链接库，进行rebase指针调整、bind符号绑定。 OC 运行时的初始化，包括OC类注册、category注册、selector唯一性检查。 初始化，包括了执行 +load() 方法、attribute((constructor)) 修饰的函数的调用、创建 C++ 静态全局变量。 当类和类别加入到runtime的时候，load方法就会被调用。 调用所有framework中的初始化方法。 调用所有load方法。 调用c++静态初始化以及C++中的构造函数 调用所有链接到目标文件的framework中的初始化方法。 针对 main 函数执行前，启动优化的几个点： 减少动态库加载。 减少加载启动后不会去使用的类或方法。 load 方法的内容可以放到首屏渲染之后在执行，可以使用initialize 方法替换掉。 Main 函数执行之后，首页渲染之前： 初始化项调整。 首页渲染： 首屏初始化所需配置文件的读写操作。 首屏列表大数据的读取。 首屏渲染的大量计算。 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 22:06:09 "},"apply/":{"url":"apply/","title":"实际应用","keywords":"","body":"TreeviewCopyright © aleen42 all right reserved, powered by aleen42 实际应用 AppDelegate如何瘦身？ 你们应用的崩溃率是多少？ 如何设计一个网络请求库？ 设计一套缓存策略。 设计一个检测主线和卡顿的方案 看过哪些三方库？说一下实现原理以及好在哪里？ 反射是什么？可以举出几个应用场景么？（知道多少说多少） 有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点，知道多少说多少） App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下，知道多少说多少） App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？（知道多少说多少） 你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？（知道多少说多少） 你知道有哪些情况会导致app卡顿，分别可以用什么方法来避免？（知道多少说多少） 实际应用 AppDelegate如何瘦身？ ... 你们应用的崩溃率是多少？ ... 如何设计一个网络请求库？ 。。。 设计一套缓存策略。 。。。 设计一个检测主线和卡顿的方案 主线程对应的是主runloop，卡顿就是无响应，所以根据对主runloop的状态监控判断某段事件内的方法调用超过一个阈值。 看过哪些三方库？说一下实现原理以及好在哪里？ 。。。 反射是什么？可以举出几个应用场景么？（知道多少说多少） ... 有哪些场景是NSOperation比GCD更容易实现的？（或是NSOperation优于GCD的几点，知道多少说多少） GCD是基于C语言编写，而NSOperationQueue是是基于GCD，Queue是对GCD更高层次的封装。 Queue可以设置两个Queue之间的依赖关系，GCD无法设置依赖关系。 优先级，NSOperation可以设置自身优先级，但是优先级高的不一定先执行。GCD只能设置队列的优先级，无法设置执行Block的优先级。 NSOperation是一个抽象类，他必须使用NSInvocationOperation和NSBlockOperation两个子类。GCD就没有继承这个东西。 App 启动优化策略？最好结合启动流程来说（main()函数的执行前后都分别说一下，知道多少说多少） ... App 无痕埋点的思路了解么？你认为理想的无痕埋点系统应该具备哪些特点？（知道多少说多少） ... 你知道有哪些情况会导致app崩溃，分别可以用什么方法拦截并化解？（知道多少说多少） 数组越界问题，给数组或者字典添加nil时，会发生crash。 多线程问题，在子线程中更新UI可能会发生crash。 主线程无响应，超出系统规定时间，被watchDog杀掉。 野指针，指向一个已经废弃对象访问内存区域。 KVO问题、NSNOotification线程问题 你知道有哪些情况会导致app卡顿，分别可以用什么方法来避免？（知道多少说多少） 卡顿问题其实就是在主线程上无法响应用户交互的问题。 复杂UI、图文混排的绘制量过大。 在主线程上在网络同步请求。 在主线程上做大量IO操作。 运算量过大，CPU持续高占用。 死锁和主子线程抢锁。 Copyright © C4xx 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-01-04 21:02:34 "}}